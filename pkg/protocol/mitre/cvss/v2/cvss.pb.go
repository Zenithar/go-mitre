// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/protocol/mitre/cvss/v2/cvss.proto

/*
Package cvssv2 is a generated protocol buffer package.

It is generated from these files:
	pkg/protocol/mitre/cvss/v2/cvss.proto

It has these top-level messages:
	BaseMetrics
	TemporalMetrics
	EnvironmentalMetrics
	Vector
	Score
	BaseScore
	TemporalScore
	EnvironmentalScore
*/
package cvssv2

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// AccessVector metric reflects how the vulnerability is exploited.
// The more remote an attacker can be to attack a host, the greater the vulnerability score.
type AccessVector int32

const (
	// Defines undefined access vector
	AccessVector_ACCESS_VECTOR_INVALID AccessVector = 0
	// Defines no access vector
	AccessVector_ACCESS_VECTOR_UNDEFINED AccessVector = 1
	// A vulnerability exploitable with only local access requires the attacker to have
	// either physical access to the vulnerable system or a local (shell) account.
	// Examples of locally exploitable vulnerabilities are peripheral attacks such as
	// Firewire/USB DMA attacks, and local privilege escalations (e.g., sudo).
	AccessVector_ACCESS_VECTOR_LOCAL AccessVector = 2
	// A vulnerability exploitable with adjacent network access requires the attacker
	// to have access to either the broadcast or collision domain of the vulnerable
	// software.  Examples of local networks include local IP subnet, Bluetooth,
	// IEEE 802.11, and local Ethernet segment.
	AccessVector_ACCESS_VECTOR_ADJACENT_NETWORK AccessVector = 3
	// A vulnerability exploitable with network access means the vulnerable software
	// is bound to the network stack and the attacker does not require local network
	// access or local access. Such a vulnerability is often termed "remotely exploitable".
	// An example of a network attack is an RPC buffer overflow.
	AccessVector_ACCESS_VECTOR_NETWORK AccessVector = 4
)

var AccessVector_name = map[int32]string{
	0: "ACCESS_VECTOR_INVALID",
	1: "ACCESS_VECTOR_UNDEFINED",
	2: "ACCESS_VECTOR_LOCAL",
	3: "ACCESS_VECTOR_ADJACENT_NETWORK",
	4: "ACCESS_VECTOR_NETWORK",
}
var AccessVector_value = map[string]int32{
	"ACCESS_VECTOR_INVALID":          0,
	"ACCESS_VECTOR_UNDEFINED":        1,
	"ACCESS_VECTOR_LOCAL":            2,
	"ACCESS_VECTOR_ADJACENT_NETWORK": 3,
	"ACCESS_VECTOR_NETWORK":          4,
}

func (x AccessVector) String() string {
	return proto.EnumName(AccessVector_name, int32(x))
}
func (AccessVector) EnumDescriptor() ([]byte, []int) { return fileDescriptorCvss, []int{0} }

// This metric measures the complexity of the attack required to exploit the vulnerability
// once an attacker has gained access to the target system. For example, consider a buffer
// overflow in an Internet service: once the target system is located, the attacker can launch
// an exploit at will.
// Other vulnerabilities, however, may require additional steps in order to be exploited.
// For example, a vulnerability in an email client is only exploited after the user downloads
// and opens a tainted attachment.
// The lower the required complexity, the higher the vulnerability score.
type AccessComplexity int32

const (
	// Defines undefined access complexity
	AccessComplexity_ACCESS_COMPLEXITY_INVALID AccessComplexity = 0
	// Defines no access complexity
	AccessComplexity_ACCESS_COMPLEXITY_UNDEFINED AccessComplexity = 1
	// Specialized access conditions exist. For example:
	// - In most configurations, the attacking party must already have elevated privileges or spoof additional
	//   systems in addition to the attacking system (e.g., DNS hijacking).
	// - The attack depends on social engineering methods that would be easily detected by knowledgeable people.
	//   For example, the victim must perform several suspicious or atypical actions.
	// - The vulnerable configuration is seen very rarely in practice.
	// - If a race condition exists, the window is very narrow.
	AccessComplexity_ACCESS_COMPLEXITY_HIGH AccessComplexity = 2
	// The access conditions are somewhat specialized; the following are examples:
	// - The attacking party is limited to a group of systems or users at some level of authorization, possibly
	//   untrusted.
	// - Some information must be gathered before a successful attack can be launched.
	// - The affected configuration is non-default, and is not commonly configured (e.g., a vulnerability
	//   present when a server performs user account authentication via a specific scheme, but not present for
	//   another authentication scheme).
	// - The attack requires a small amount of social engineering that might occasionally fool cautious users
	//   (e.g., phishing attacks that modify a web browsers status bar to show a false link, having to be on
	//   someones buddy list before sending an IM exploit).
	AccessComplexity_ACCESS_COMPLEXITY_MEDIUM AccessComplexity = 3
	// Specialized access conditions or extenuating circumstances do not exist. The following are examples:
	// - The affected product typically requires access to a wide range of systems and users, possibly
	//   anonymous and untrusted (e.g., Internet-facing web or mail server).
	// - The affected configuration is default or ubiquitous.
	// - The attack can be performed manually and requires little skill or additional information gathering.
	// - The race condition is a lazy one (i.e., it is technically a race but easily winnable).
	AccessComplexity_ACCESS_COMPLEXITY_LOW AccessComplexity = 4
)

var AccessComplexity_name = map[int32]string{
	0: "ACCESS_COMPLEXITY_INVALID",
	1: "ACCESS_COMPLEXITY_UNDEFINED",
	2: "ACCESS_COMPLEXITY_HIGH",
	3: "ACCESS_COMPLEXITY_MEDIUM",
	4: "ACCESS_COMPLEXITY_LOW",
}
var AccessComplexity_value = map[string]int32{
	"ACCESS_COMPLEXITY_INVALID":   0,
	"ACCESS_COMPLEXITY_UNDEFINED": 1,
	"ACCESS_COMPLEXITY_HIGH":      2,
	"ACCESS_COMPLEXITY_MEDIUM":    3,
	"ACCESS_COMPLEXITY_LOW":       4,
}

func (x AccessComplexity) String() string {
	return proto.EnumName(AccessComplexity_name, int32(x))
}
func (AccessComplexity) EnumDescriptor() ([]byte, []int) { return fileDescriptorCvss, []int{1} }

// This metric measures the number of times an attacker must authenticate to a target in order to exploit
// a vulnerability. This metric does not gauge the strength or complexity of the authentication process,
// only that an attacker is required to provide credentials before an exploit may occur.
// The fewer authentication instances that are required, the higher the vulnerability score.
//
// The metric should be applied based on the authentication the attacker requires before launching an attack.
// For example, if a mail server is vulnerable to a command that can be issued before a user authenticates,
// the metric should be scored as "None" because the attacker can launch the exploit before credentials are
// required.  If the vulnerable command is only available after successful authentication, then the
// vulnerability should be scored as "Single" or "Multiple," depending on how many instances of authentication
//  must occur before issuing the command.
type Authentication int32

const (
	// Defines default authentication value
	Authentication_AUTHENTICATION_INVALID Authentication = 0
	// Defines not defined authentication value
	Authentication_AUTHENTICATION_UNDEFINED Authentication = 1
	// Exploiting the vulnerability requires that the attacker authenticate two or more times, even if
	// the same credentials are used each time. An example is an attacker authenticating to an operating
	// system in addition to providing credentials to access an application hosted on that system.
	Authentication_AUTHENTICATION_MULTIPLE Authentication = 2
	// The vulnerability requires an attacker to be logged into the system (such as at a command line or
	// via a desktop session or web interface).
	Authentication_AUTHENTICATION_SINGLE Authentication = 3
	// Authentication is not required to exploit the vulnerability.
	Authentication_AUTHENTICATION_NONE Authentication = 4
)

var Authentication_name = map[int32]string{
	0: "AUTHENTICATION_INVALID",
	1: "AUTHENTICATION_UNDEFINED",
	2: "AUTHENTICATION_MULTIPLE",
	3: "AUTHENTICATION_SINGLE",
	4: "AUTHENTICATION_NONE",
}
var Authentication_value = map[string]int32{
	"AUTHENTICATION_INVALID":   0,
	"AUTHENTICATION_UNDEFINED": 1,
	"AUTHENTICATION_MULTIPLE":  2,
	"AUTHENTICATION_SINGLE":    3,
	"AUTHENTICATION_NONE":      4,
}

func (x Authentication) String() string {
	return proto.EnumName(Authentication_name, int32(x))
}
func (Authentication) EnumDescriptor() ([]byte, []int) { return fileDescriptorCvss, []int{2} }

// This metric measures the impact on confidentiality of a successfully exploited vulnerability.
// Confidentiality refers to limiting information access and disclosure to only authorized users, as well
// as preventing access by, or disclosure to, unauthorized ones. Increased confidentiality impact increases
// the vulnerability score.
type ConfidentialityImpact int32

const (
	ConfidentialityImpact_CONFIDENTIALITY_IMPACT_INVALID   ConfidentialityImpact = 0
	ConfidentialityImpact_CONFIDENTIALITY_IMPACT_UNDEFINED ConfidentialityImpact = 1
	// There is no impact to the confidentiality of the system.
	ConfidentialityImpact_CONFIDENTIALITY_IMPACT_NONE ConfidentialityImpact = 2
	// There is considerable informational disclosure. Access to some system files is possible, but the
	// attacker does not have control over what is obtained, or the scope of the loss is constrained.
	// An example is a vulnerability that divulges only certain tables in a database.
	ConfidentialityImpact_CONFIDENTIALITY_IMPACT_PARTIAL ConfidentialityImpact = 3
	// There is total information disclosure, resulting in all system files being revealed. The attacker
	// is able to read all of the system's data (memory, files, etc.)
	ConfidentialityImpact_CONFIDENTIALITY_IMPACT_COMPLETE ConfidentialityImpact = 4
)

var ConfidentialityImpact_name = map[int32]string{
	0: "CONFIDENTIALITY_IMPACT_INVALID",
	1: "CONFIDENTIALITY_IMPACT_UNDEFINED",
	2: "CONFIDENTIALITY_IMPACT_NONE",
	3: "CONFIDENTIALITY_IMPACT_PARTIAL",
	4: "CONFIDENTIALITY_IMPACT_COMPLETE",
}
var ConfidentialityImpact_value = map[string]int32{
	"CONFIDENTIALITY_IMPACT_INVALID":   0,
	"CONFIDENTIALITY_IMPACT_UNDEFINED": 1,
	"CONFIDENTIALITY_IMPACT_NONE":      2,
	"CONFIDENTIALITY_IMPACT_PARTIAL":   3,
	"CONFIDENTIALITY_IMPACT_COMPLETE":  4,
}

func (x ConfidentialityImpact) String() string {
	return proto.EnumName(ConfidentialityImpact_name, int32(x))
}
func (ConfidentialityImpact) EnumDescriptor() ([]byte, []int) { return fileDescriptorCvss, []int{3} }

// This metric measures the impact to integrity of a successfully exploited vulnerability.
// Integrity refers to the trustworthiness and guaranteed veracity of information.
// Increased integrity impact increases the vulnerability score.
type IntegrityImpact int32

const (
	IntegrityImpact_INTEGRITY_IMPACT_INVALID   IntegrityImpact = 0
	IntegrityImpact_INTEGRITY_IMPACT_UNDEFINED IntegrityImpact = 1
	// There is no impact to the integrity of the system.
	IntegrityImpact_INTEGRITY_IMPACT_NONE IntegrityImpact = 2
	// Modification of some system files or information is possible, but the attacker does not have
	// control over what can be modified, or the scope of what the attacker can affect is limited.
	// For example, system or application files may be overwritten or modified, but either the attacker
	// has no control over which files are affected or the attacker can modify files within only a limited
	// context or scope.
	IntegrityImpact_INTEGRITY_IMPACT_PARTIAL IntegrityImpact = 3
	// There is a total compromise of system integrity. There is a complete loss of system protection,
	// resulting in the entire system being compromised. The attacker is able to modify any files on the
	// target system.
	IntegrityImpact_INTEGRITY_IMPACT_COMPLETE IntegrityImpact = 4
)

var IntegrityImpact_name = map[int32]string{
	0: "INTEGRITY_IMPACT_INVALID",
	1: "INTEGRITY_IMPACT_UNDEFINED",
	2: "INTEGRITY_IMPACT_NONE",
	3: "INTEGRITY_IMPACT_PARTIAL",
	4: "INTEGRITY_IMPACT_COMPLETE",
}
var IntegrityImpact_value = map[string]int32{
	"INTEGRITY_IMPACT_INVALID":   0,
	"INTEGRITY_IMPACT_UNDEFINED": 1,
	"INTEGRITY_IMPACT_NONE":      2,
	"INTEGRITY_IMPACT_PARTIAL":   3,
	"INTEGRITY_IMPACT_COMPLETE":  4,
}

func (x IntegrityImpact) String() string {
	return proto.EnumName(IntegrityImpact_name, int32(x))
}
func (IntegrityImpact) EnumDescriptor() ([]byte, []int) { return fileDescriptorCvss, []int{4} }

// This metric measures the impact to availability of a successfully exploited vulnerability.
// Availability refers to the accessibility of information resources. Attacks that consume network bandwidth,
// processor cycles, or disk space all impact the availability of a system.
// Increased availability impact increases the vulnerability score.
type AvailabilityImpact int32

const (
	AvailabilityImpact_AVAILABILITY_IMPACT_INVALID   AvailabilityImpact = 0
	AvailabilityImpact_AVAILABILITY_IMPACT_UNDEFINED AvailabilityImpact = 1
	// There is no impact to the availability of the system.
	AvailabilityImpact_AVAILABILITY_IMPACT_NONE AvailabilityImpact = 2
	// There is reduced performance or interruptions in resource availability. An example is a network-based
	// flood attack that permits a limited number of successful connections to an Internet service.
	AvailabilityImpact_AVAILABILITY_IMPACT_PARTIAL AvailabilityImpact = 3
	// There is a total shutdown of the affected resource. The attacker can render the resource completely
	// unavailable.
	AvailabilityImpact_AVAILABILITY_IMPACT_COMPLETE AvailabilityImpact = 4
)

var AvailabilityImpact_name = map[int32]string{
	0: "AVAILABILITY_IMPACT_INVALID",
	1: "AVAILABILITY_IMPACT_UNDEFINED",
	2: "AVAILABILITY_IMPACT_NONE",
	3: "AVAILABILITY_IMPACT_PARTIAL",
	4: "AVAILABILITY_IMPACT_COMPLETE",
}
var AvailabilityImpact_value = map[string]int32{
	"AVAILABILITY_IMPACT_INVALID":   0,
	"AVAILABILITY_IMPACT_UNDEFINED": 1,
	"AVAILABILITY_IMPACT_NONE":      2,
	"AVAILABILITY_IMPACT_PARTIAL":   3,
	"AVAILABILITY_IMPACT_COMPLETE":  4,
}

func (x AvailabilityImpact) String() string {
	return proto.EnumName(AvailabilityImpact_name, int32(x))
}
func (AvailabilityImpact) EnumDescriptor() ([]byte, []int) { return fileDescriptorCvss, []int{5} }

// This metric measures the current state of exploit techniques or code availability. Public availability
// of easy-to-use exploit code increases the number of potential attackers by including those who are
// unskilled, thereby increasing the severity of the vulnerability.
//
// Initially, real-world exploitation may only be theoretical. Publication of proof of concept code,
// functional exploit code, or sufficient technical details necessary to exploit the vulnerability may follow.
// Furthermore, the exploit code available may progress from a proof-of-concept demonstration to exploit code
// that is successful in exploiting the vulnerability consistently. In severe cases, it may be delivered as
// the payload of a network-based worm or virus. The more easily a vulnerability can be exploited, the higher
// the vulnerability score.
type Exploitability int32

const (
	Exploitability_EXPLOITABILITY_INVALID Exploitability = 0
	// No exploit code is available, or an exploit is entirely theoretical.
	Exploitability_EXPLOITABILITY_UNPROVEN Exploitability = 1
	// Proof-of-concept exploit code or an attack demonstration that is not practical for most systems is
	// available. The code or technique is not functional in all situations and may require substantial
	// modification by a skilled attacker.
	Exploitability_EXPLOITABILITY_PROOF_OF_CONCEPT Exploitability = 2
	// Functional exploit code is available. The code works in most situations where the vulnerability exists.
	Exploitability_EXPLOITABILITY_FUNCTIONAL Exploitability = 3
	// Either the vulnerability is exploitable by functional mobile autonomous code, or no exploit is
	// required (manual trigger) and details are widely available. The code works in every situation,
	// or is actively being delivered via a mobile autonomous agent (such as a worm or virus).
	Exploitability_EXPLOITABILITY_HIGH Exploitability = 4
	// Assigning this value to the metric will not influence the score. It is a signal to the equation
	// to skip this metric.
	Exploitability_EXPLOITABILITY_NOT_DEFINED Exploitability = 5
)

var Exploitability_name = map[int32]string{
	0: "EXPLOITABILITY_INVALID",
	1: "EXPLOITABILITY_UNPROVEN",
	2: "EXPLOITABILITY_PROOF_OF_CONCEPT",
	3: "EXPLOITABILITY_FUNCTIONAL",
	4: "EXPLOITABILITY_HIGH",
	5: "EXPLOITABILITY_NOT_DEFINED",
}
var Exploitability_value = map[string]int32{
	"EXPLOITABILITY_INVALID":          0,
	"EXPLOITABILITY_UNPROVEN":         1,
	"EXPLOITABILITY_PROOF_OF_CONCEPT": 2,
	"EXPLOITABILITY_FUNCTIONAL":       3,
	"EXPLOITABILITY_HIGH":             4,
	"EXPLOITABILITY_NOT_DEFINED":      5,
}

func (x Exploitability) String() string {
	return proto.EnumName(Exploitability_name, int32(x))
}
func (Exploitability) EnumDescriptor() ([]byte, []int) { return fileDescriptorCvss, []int{6} }

// The remediation level of a vulnerability is an important factor for prioritization. The typical vulnerability
// is unpatched when initially published. Workarounds or hotfixes may offer interim remediation until an
// official patch or upgrade is issued. Each of these respective stages adjusts the temporal score downwards,
// reflecting the decreasing urgency as remediation becomes final.
// The less official and permanent a fix, the higher the vulnerability score is.
type RemediationLevel int32

const (
	RemediationLevel_REMEDIATION_LEVEL_INVALID RemediationLevel = 0
	// A complete vendor solution is available. Either the vendor has issued an official patch, or an upgrade is available.
	RemediationLevel_REMEDIATION_LEVEL_OFFICIAL_FIX RemediationLevel = 1
	// There is an official but temporary fix available. This includes instances where the vendor issues a temporary
	// hotfix, tool, or workaround.
	RemediationLevel_REMEDIATION_LEVEL_TEMPORARY_FIX RemediationLevel = 2
	// There is an unofficial, non-vendor solution available. In some cases, users of the affected technology
	// will create a patch of their own or provide steps to work around or otherwise mitigate the vulnerability.
	RemediationLevel_REMEDIATION_LEVEL_WORKAROUND RemediationLevel = 3
	// There is either no solution available or it is impossible to apply.
	RemediationLevel_REMEDIATION_LEVEL_UNAVAILABLE RemediationLevel = 4
	// Assigning this value to the metric will not influence the score. It is a signal to the equation
	// to skip this metric.
	RemediationLevel_REMEDIATION_LEVEL_NO_DEFINED RemediationLevel = 5
)

var RemediationLevel_name = map[int32]string{
	0: "REMEDIATION_LEVEL_INVALID",
	1: "REMEDIATION_LEVEL_OFFICIAL_FIX",
	2: "REMEDIATION_LEVEL_TEMPORARY_FIX",
	3: "REMEDIATION_LEVEL_WORKAROUND",
	4: "REMEDIATION_LEVEL_UNAVAILABLE",
	5: "REMEDIATION_LEVEL_NO_DEFINED",
}
var RemediationLevel_value = map[string]int32{
	"REMEDIATION_LEVEL_INVALID":       0,
	"REMEDIATION_LEVEL_OFFICIAL_FIX":  1,
	"REMEDIATION_LEVEL_TEMPORARY_FIX": 2,
	"REMEDIATION_LEVEL_WORKAROUND":    3,
	"REMEDIATION_LEVEL_UNAVAILABLE":   4,
	"REMEDIATION_LEVEL_NO_DEFINED":    5,
}

func (x RemediationLevel) String() string {
	return proto.EnumName(RemediationLevel_name, int32(x))
}
func (RemediationLevel) EnumDescriptor() ([]byte, []int) { return fileDescriptorCvss, []int{7} }

// This metric measures the degree of confidence in the existence of the vulnerability and the credibility of
// the known technical details. Sometimes, only the existence of vulnerabilities are publicized, but without
// specific details. The vulnerability may later be corroborated and then confirmed through acknowledgement
// by the author or vendor of the affected technology. The urgency of a vulnerability is higher when a
// vulnerability is known to exist with certainty. This metric also suggests the level of technical knowledge
// available to would-be attackers. The more a vulnerability is validated by the vendor or other reputable
// sources, the higher the score.
type ReportConfidence int32

const (
	ReportConfidence_REPORT_CONFIDENCE_INVALID ReportConfidence = 0
	// There is a single unconfirmed source or possibly multiple conflicting reports. There is little
	// confidence in the validity of the reports. An example is a rumor that surfaces from the hacker underground.
	ReportConfidence_REPORT_CONFIDENCE_UNCONFIRMED ReportConfidence = 1
	// There are multiple non-official sources, possibly including independent security companies or research
	// organizations. At this point there may be conflicting technical details or some other lingering ambiguity.
	ReportConfidence_REPORT_CONFIDENCE_UNCORROBORATED ReportConfidence = 2
	// The vulnerability has been acknowledged by the vendor or author of the affected technology. The vulnerability
	// may also be Confirmed when its existence is confirmed from an external event such as publication of functional
	// or proof-of-concept exploit code or widespread exploitation.
	ReportConfidence_REPORT_CONFIDENCE_CONFIRMED ReportConfidence = 3
	// Assigning this value to the metric will not influence the score. It is a signal to the equation to skip this metric.
	ReportConfidence_REPORT_CONFIDENCE_NOT_DEFINED ReportConfidence = 4
)

var ReportConfidence_name = map[int32]string{
	0: "REPORT_CONFIDENCE_INVALID",
	1: "REPORT_CONFIDENCE_UNCONFIRMED",
	2: "REPORT_CONFIDENCE_UNCORROBORATED",
	3: "REPORT_CONFIDENCE_CONFIRMED",
	4: "REPORT_CONFIDENCE_NOT_DEFINED",
}
var ReportConfidence_value = map[string]int32{
	"REPORT_CONFIDENCE_INVALID":        0,
	"REPORT_CONFIDENCE_UNCONFIRMED":    1,
	"REPORT_CONFIDENCE_UNCORROBORATED": 2,
	"REPORT_CONFIDENCE_CONFIRMED":      3,
	"REPORT_CONFIDENCE_NOT_DEFINED":    4,
}

func (x ReportConfidence) String() string {
	return proto.EnumName(ReportConfidence_name, int32(x))
}
func (ReportConfidence) EnumDescriptor() ([]byte, []int) { return fileDescriptorCvss, []int{8} }

// This metric measures the potential for loss of life or physical assets through damage or theft of property
// or equipment. The metric may also measure economic loss of productivity or revenue.
// Naturally, the greater the damage potential, the higher the vulnerability score.
type CollateralDamagePotential int32

const (
	CollateralDamagePotential_COLLATERAL_DAMAGE_POTENTIAL_INVALID CollateralDamagePotential = 0
	// There is no potential for loss of life, physical assets, productivity or revenue.
	CollateralDamagePotential_COLLATERAL_DAMAGE_POTENTIAL_NONE CollateralDamagePotential = 1
	// A successful exploit of this vulnerability may result in slight physical or property damage.
	// Or, there may be a slight loss of revenue or productivity to the organization.
	CollateralDamagePotential_COLLATERAL_DAMAGE_POTENTIAL_LOW CollateralDamagePotential = 2
	// A successful exploit of this vulnerability may result in moderate physical or property damage.
	// Or, there may be a moderate loss of revenue or productivity to the organization.
	CollateralDamagePotential_COLLATERAL_DAMAGE_POTENTIAL_LOW_MEDIUM CollateralDamagePotential = 3
	// A successful exploit of this vulnerability may result in significant physical or property damage or loss.
	// Or, there may be a significant loss of revenue or productivity.
	CollateralDamagePotential_COLLATERAL_DAMAGE_POTENTIAL_MEDIUM_HIGH CollateralDamagePotential = 4
	// A successful exploit of this vulnerability may result in catastrophic physical or property damage and loss.
	// Or, there may be a catastrophic loss of revenue or productivity.
	CollateralDamagePotential_COLLATERAL_DAMAGE_POTENTIAL_HIGH CollateralDamagePotential = 5
	// Assigning this value to the metric will not influence the score. It is a signal to the equation to skip this metric.
	CollateralDamagePotential_COLLATERAL_DAMAGE_POTENTIAL_NOT_DEFINED CollateralDamagePotential = 6
)

var CollateralDamagePotential_name = map[int32]string{
	0: "COLLATERAL_DAMAGE_POTENTIAL_INVALID",
	1: "COLLATERAL_DAMAGE_POTENTIAL_NONE",
	2: "COLLATERAL_DAMAGE_POTENTIAL_LOW",
	3: "COLLATERAL_DAMAGE_POTENTIAL_LOW_MEDIUM",
	4: "COLLATERAL_DAMAGE_POTENTIAL_MEDIUM_HIGH",
	5: "COLLATERAL_DAMAGE_POTENTIAL_HIGH",
	6: "COLLATERAL_DAMAGE_POTENTIAL_NOT_DEFINED",
}
var CollateralDamagePotential_value = map[string]int32{
	"COLLATERAL_DAMAGE_POTENTIAL_INVALID":     0,
	"COLLATERAL_DAMAGE_POTENTIAL_NONE":        1,
	"COLLATERAL_DAMAGE_POTENTIAL_LOW":         2,
	"COLLATERAL_DAMAGE_POTENTIAL_LOW_MEDIUM":  3,
	"COLLATERAL_DAMAGE_POTENTIAL_MEDIUM_HIGH": 4,
	"COLLATERAL_DAMAGE_POTENTIAL_HIGH":        5,
	"COLLATERAL_DAMAGE_POTENTIAL_NOT_DEFINED": 6,
}

func (x CollateralDamagePotential) String() string {
	return proto.EnumName(CollateralDamagePotential_name, int32(x))
}
func (CollateralDamagePotential) EnumDescriptor() ([]byte, []int) { return fileDescriptorCvss, []int{9} }

// This metric measures the proportion of vulnerable systems. It is meant as an environment-specific indicator
// in order to approximate the percentage of systems that could be affected by the vulnerability.
// The greater the proportion of vulnerable systems, the higher the score.
type TargetDistribution int32

const (
	TargetDistribution_TARGET_DISTRIBUTION_INVALID TargetDistribution = 0
	// No target systems exist, or targets are so highly specialized that they only exist in a laboratory setting.
	// Effectively 0% of the environment is at risk.
	TargetDistribution_TARGET_DISTRIBUTION_NONE TargetDistribution = 1
	// Targets exist inside the environment, but on a small scale. Between 1% - 25% of the total environment is at risk.
	TargetDistribution_TARGET_DISTRIBUTION_LOW TargetDistribution = 2
	// Targets exist inside the environment, but on a medium scale. Between 26% - 75% of the total environment is at risk.
	TargetDistribution_TARGET_DISTRIBUTION_MEDIUM TargetDistribution = 3
	// Targets exist inside the environment on a considerable scale. Between 76% - 100% of the total environment is considered at risk.
	TargetDistribution_TARGET_DISTRIBUTION_HIGH TargetDistribution = 4
	// Assigning this value to the metric will not influence the score. It is a signal to the equation to skip this metric.
	TargetDistribution_TARGET_DISTRIBUTION_NOT_DEFINED TargetDistribution = 5
)

var TargetDistribution_name = map[int32]string{
	0: "TARGET_DISTRIBUTION_INVALID",
	1: "TARGET_DISTRIBUTION_NONE",
	2: "TARGET_DISTRIBUTION_LOW",
	3: "TARGET_DISTRIBUTION_MEDIUM",
	4: "TARGET_DISTRIBUTION_HIGH",
	5: "TARGET_DISTRIBUTION_NOT_DEFINED",
}
var TargetDistribution_value = map[string]int32{
	"TARGET_DISTRIBUTION_INVALID":     0,
	"TARGET_DISTRIBUTION_NONE":        1,
	"TARGET_DISTRIBUTION_LOW":         2,
	"TARGET_DISTRIBUTION_MEDIUM":      3,
	"TARGET_DISTRIBUTION_HIGH":        4,
	"TARGET_DISTRIBUTION_NOT_DEFINED": 5,
}

func (x TargetDistribution) String() string {
	return proto.EnumName(TargetDistribution_name, int32(x))
}
func (TargetDistribution) EnumDescriptor() ([]byte, []int) { return fileDescriptorCvss, []int{10} }

// These metrics enable the analyst to customize the CVSS score depending on the importance of the affected IT asset to a
// users organization, measured in terms of confidentiality, integrity, and availability, That is, if an IT asset supports a
// business function for which availability is most important, the analyst can assign a greater value to availability, relative to
// confidentiality and integrity. Each security requirement has three possible values: low, medium, or high.
//
// The full effect on the environmental score is determined by the corresponding base impact metrics (please note that
// the base confidentiality, integrity and availability impact metrics, themselves, are not changed). That is, these metrics
// modify the environmental score by reweighting the (base) confidentiality, integrity, and availability impact metrics.
// For example, the confidentiality impact (C) metric has increased weight if the confidentiality requirement (CR) is high.
// Likewise, the confidentiality impact metric has decreased weight if the confidentiality requirement is low. The confidentiality
// impact metric weighting is neutral if the confidentiality requirement is medium. This same logic is applied to the integrity
// and availability requirements.
//
// Note that the confidentiality requirement will not affect the environmental score if the (base) confidentiality impact is
// set to none. Also, increasing the confidentiality requirement from medium to high will not change the environmental score
// when the (base) impact metrics are set to complete. This is because the impact sub score (part of the base score that
// calculates impact) is already at a maximum value of 10.
//
// The possible values for the security requirements are listed in Table 12. For brevity, the same table is used for all three
// metrics. The greater the security requirement, the higher the score (remember that medium is considered the default).
// These metrics will modify the score as much as plus or minus 2.5.
type SecurityRequirement int32

const (
	SecurityRequirement_SECURITY_REQUIREMENT_INVALID SecurityRequirement = 0
	// Loss of [confidentiality / integrity / availability] is likely to have only a limited adverse effect on the organization
	// or individuals associated with the organization (e.g., employees, customers).
	SecurityRequirement_SECURITY_REQUIREMENT_LOW SecurityRequirement = 1
	// Loss of [confidentiality / integrity / availability] is likely to have a serious adverse effect on the organization
	// or individuals associated with the organization (e.g., employees, customers).
	SecurityRequirement_SECURITY_REQUIREMENT_MEDIUM SecurityRequirement = 2
	// Loss of [confidentiality / integrity / availability] is likely to have a catastrophic adverse effect on the
	// organization or individuals associated with the organization (e.g., employees, customers).
	SecurityRequirement_SECURITY_REQUIREMENT_HIGH SecurityRequirement = 3
	// Assigning this value to the metric will not influence the score. It is a signal to the equation to skip this metric.
	SecurityRequirement_SECURITY_REQUIREMENT_NOT_DEFINED SecurityRequirement = 4
)

var SecurityRequirement_name = map[int32]string{
	0: "SECURITY_REQUIREMENT_INVALID",
	1: "SECURITY_REQUIREMENT_LOW",
	2: "SECURITY_REQUIREMENT_MEDIUM",
	3: "SECURITY_REQUIREMENT_HIGH",
	4: "SECURITY_REQUIREMENT_NOT_DEFINED",
}
var SecurityRequirement_value = map[string]int32{
	"SECURITY_REQUIREMENT_INVALID":     0,
	"SECURITY_REQUIREMENT_LOW":         1,
	"SECURITY_REQUIREMENT_MEDIUM":      2,
	"SECURITY_REQUIREMENT_HIGH":        3,
	"SECURITY_REQUIREMENT_NOT_DEFINED": 4,
}

func (x SecurityRequirement) String() string {
	return proto.EnumName(SecurityRequirement_name, int32(x))
}
func (SecurityRequirement) EnumDescriptor() ([]byte, []int) { return fileDescriptorCvss, []int{11} }

// Severity scale.
type Severity int32

const (
	Severity_SEVERITY_INVALID   Severity = 0
	Severity_SEVERITY_UNDEFINED Severity = 1
	// Low severity (0.0 - 3.9)
	Severity_SEVERITY_LOW Severity = 2
	// Medium severity (4.0 - 6.9)
	Severity_SEVERITY_MEDIUM Severity = 3
	// High severity (7.0 - 10.0)
	Severity_SEVERITY_HIGH Severity = 4
)

var Severity_name = map[int32]string{
	0: "SEVERITY_INVALID",
	1: "SEVERITY_UNDEFINED",
	2: "SEVERITY_LOW",
	3: "SEVERITY_MEDIUM",
	4: "SEVERITY_HIGH",
}
var Severity_value = map[string]int32{
	"SEVERITY_INVALID":   0,
	"SEVERITY_UNDEFINED": 1,
	"SEVERITY_LOW":       2,
	"SEVERITY_MEDIUM":    3,
	"SEVERITY_HIGH":      4,
}

func (x Severity) String() string {
	return proto.EnumName(Severity_name, int32(x))
}
func (Severity) EnumDescriptor() ([]byte, []int) { return fileDescriptorCvss, []int{12} }

// The base metric group captures the characteristics of a vulnerability that are constant with time and
// across user environments. The Access Vector, Access Complexity, and Authentication metrics capture how
// the vulnerability is accessed and whether or not extra conditions are required to exploit it. The three
// impact metrics measure how a vulnerability, if exploited, will directly affect an IT asset, where the
// impacts are independently defined as the degree of loss of confidentiality, integrity, and availability.
// For example, a vulnerability could cause a partial loss of integrity and availability, but no loss of
// confidentiality.
type BaseMetrics struct {
	AccessVector          AccessVector          `protobuf:"varint,1,opt,name=access_vector,json=accessVector,proto3,enum=mitre.cvss.v2.AccessVector" json:"access_vector,omitempty"`
	AccessComplexity      AccessComplexity      `protobuf:"varint,2,opt,name=access_complexity,json=accessComplexity,proto3,enum=mitre.cvss.v2.AccessComplexity" json:"access_complexity,omitempty"`
	Authentication        Authentication        `protobuf:"varint,3,opt,name=authentication,proto3,enum=mitre.cvss.v2.Authentication" json:"authentication,omitempty"`
	ConfidentialityImpact ConfidentialityImpact `protobuf:"varint,4,opt,name=confidentiality_impact,json=confidentialityImpact,proto3,enum=mitre.cvss.v2.ConfidentialityImpact" json:"confidentiality_impact,omitempty"`
	IntegrityImpact       IntegrityImpact       `protobuf:"varint,5,opt,name=integrity_impact,json=integrityImpact,proto3,enum=mitre.cvss.v2.IntegrityImpact" json:"integrity_impact,omitempty"`
	AvailabilityImpact    AvailabilityImpact    `protobuf:"varint,6,opt,name=availability_impact,json=availabilityImpact,proto3,enum=mitre.cvss.v2.AvailabilityImpact" json:"availability_impact,omitempty"`
}

func (m *BaseMetrics) Reset()                    { *m = BaseMetrics{} }
func (m *BaseMetrics) String() string            { return proto.CompactTextString(m) }
func (*BaseMetrics) ProtoMessage()               {}
func (*BaseMetrics) Descriptor() ([]byte, []int) { return fileDescriptorCvss, []int{0} }

func (m *BaseMetrics) GetAccessVector() AccessVector {
	if m != nil {
		return m.AccessVector
	}
	return AccessVector_ACCESS_VECTOR_INVALID
}

func (m *BaseMetrics) GetAccessComplexity() AccessComplexity {
	if m != nil {
		return m.AccessComplexity
	}
	return AccessComplexity_ACCESS_COMPLEXITY_INVALID
}

func (m *BaseMetrics) GetAuthentication() Authentication {
	if m != nil {
		return m.Authentication
	}
	return Authentication_AUTHENTICATION_INVALID
}

func (m *BaseMetrics) GetConfidentialityImpact() ConfidentialityImpact {
	if m != nil {
		return m.ConfidentialityImpact
	}
	return ConfidentialityImpact_CONFIDENTIALITY_IMPACT_INVALID
}

func (m *BaseMetrics) GetIntegrityImpact() IntegrityImpact {
	if m != nil {
		return m.IntegrityImpact
	}
	return IntegrityImpact_INTEGRITY_IMPACT_INVALID
}

func (m *BaseMetrics) GetAvailabilityImpact() AvailabilityImpact {
	if m != nil {
		return m.AvailabilityImpact
	}
	return AvailabilityImpact_AVAILABILITY_IMPACT_INVALID
}

// The threat posed by a vulnerability may change over time. Three such factors that CVSS captures are:
// confirmation of the technical details of a vulnerability, the remediation status of the vulnerability,
// and the availability of exploit code or techniques. Since temporal metrics are optional they each include
// a metric value that has no effect on the score. This value is used when the user feels the particular
// metric does not apply and wishes to "skip over" it.
type TemporalMetrics struct {
	Exploitability   Exploitability   `protobuf:"varint,1,opt,name=exploitability,proto3,enum=mitre.cvss.v2.Exploitability" json:"exploitability,omitempty"`
	RemediationLevel RemediationLevel `protobuf:"varint,2,opt,name=remediation_level,json=remediationLevel,proto3,enum=mitre.cvss.v2.RemediationLevel" json:"remediation_level,omitempty"`
	ReportConfidence ReportConfidence `protobuf:"varint,3,opt,name=report_confidence,json=reportConfidence,proto3,enum=mitre.cvss.v2.ReportConfidence" json:"report_confidence,omitempty"`
}

func (m *TemporalMetrics) Reset()                    { *m = TemporalMetrics{} }
func (m *TemporalMetrics) String() string            { return proto.CompactTextString(m) }
func (*TemporalMetrics) ProtoMessage()               {}
func (*TemporalMetrics) Descriptor() ([]byte, []int) { return fileDescriptorCvss, []int{1} }

func (m *TemporalMetrics) GetExploitability() Exploitability {
	if m != nil {
		return m.Exploitability
	}
	return Exploitability_EXPLOITABILITY_INVALID
}

func (m *TemporalMetrics) GetRemediationLevel() RemediationLevel {
	if m != nil {
		return m.RemediationLevel
	}
	return RemediationLevel_REMEDIATION_LEVEL_INVALID
}

func (m *TemporalMetrics) GetReportConfidence() ReportConfidence {
	if m != nil {
		return m.ReportConfidence
	}
	return ReportConfidence_REPORT_CONFIDENCE_INVALID
}

// Different environments can have an immense bearing on the risk that a vulnerability poses to an organization
// and its stakeholders. The CVSS environmental metric group captures the characteristics of a vulnerability
// that are associated with a user's IT environment. Since environmental metrics are optional they each
// include a metric value that has no effect on the score. This value is used when the user feels the
// particular metric does not apply and wishes to "skip over" it.
type EnvironmentalMetrics struct {
	CollateralDamagePotential  CollateralDamagePotential `protobuf:"varint,1,opt,name=collateral_damage_potential,json=collateralDamagePotential,proto3,enum=mitre.cvss.v2.CollateralDamagePotential" json:"collateral_damage_potential,omitempty"`
	TargetDistribution         TargetDistribution        `protobuf:"varint,2,opt,name=target_distribution,json=targetDistribution,proto3,enum=mitre.cvss.v2.TargetDistribution" json:"target_distribution,omitempty"`
	ConfidentialityRequirement SecurityRequirement       `protobuf:"varint,3,opt,name=confidentiality_requirement,json=confidentialityRequirement,proto3,enum=mitre.cvss.v2.SecurityRequirement" json:"confidentiality_requirement,omitempty"`
	IntegrityRequirement       SecurityRequirement       `protobuf:"varint,4,opt,name=integrity_requirement,json=integrityRequirement,proto3,enum=mitre.cvss.v2.SecurityRequirement" json:"integrity_requirement,omitempty"`
	AvailabilityRequirement    SecurityRequirement       `protobuf:"varint,5,opt,name=availability_requirement,json=availabilityRequirement,proto3,enum=mitre.cvss.v2.SecurityRequirement" json:"availability_requirement,omitempty"`
}

func (m *EnvironmentalMetrics) Reset()                    { *m = EnvironmentalMetrics{} }
func (m *EnvironmentalMetrics) String() string            { return proto.CompactTextString(m) }
func (*EnvironmentalMetrics) ProtoMessage()               {}
func (*EnvironmentalMetrics) Descriptor() ([]byte, []int) { return fileDescriptorCvss, []int{2} }

func (m *EnvironmentalMetrics) GetCollateralDamagePotential() CollateralDamagePotential {
	if m != nil {
		return m.CollateralDamagePotential
	}
	return CollateralDamagePotential_COLLATERAL_DAMAGE_POTENTIAL_INVALID
}

func (m *EnvironmentalMetrics) GetTargetDistribution() TargetDistribution {
	if m != nil {
		return m.TargetDistribution
	}
	return TargetDistribution_TARGET_DISTRIBUTION_INVALID
}

func (m *EnvironmentalMetrics) GetConfidentialityRequirement() SecurityRequirement {
	if m != nil {
		return m.ConfidentialityRequirement
	}
	return SecurityRequirement_SECURITY_REQUIREMENT_INVALID
}

func (m *EnvironmentalMetrics) GetIntegrityRequirement() SecurityRequirement {
	if m != nil {
		return m.IntegrityRequirement
	}
	return SecurityRequirement_SECURITY_REQUIREMENT_INVALID
}

func (m *EnvironmentalMetrics) GetAvailabilityRequirement() SecurityRequirement {
	if m != nil {
		return m.AvailabilityRequirement
	}
	return SecurityRequirement_SECURITY_REQUIREMENT_INVALID
}

// Vector defines CVSS object attributes.
type Vector struct {
	BaseMetrics          *BaseMetrics          `protobuf:"bytes,1,opt,name=base_metrics,json=baseMetrics" json:"base_metrics,omitempty"`
	TemporalMetrics      *TemporalMetrics      `protobuf:"bytes,2,opt,name=temporal_metrics,json=temporalMetrics" json:"temporal_metrics,omitempty"`
	EnvironmentalMetrics *EnvironmentalMetrics `protobuf:"bytes,3,opt,name=environmental_metrics,json=environmentalMetrics" json:"environmental_metrics,omitempty"`
}

func (m *Vector) Reset()                    { *m = Vector{} }
func (m *Vector) String() string            { return proto.CompactTextString(m) }
func (*Vector) ProtoMessage()               {}
func (*Vector) Descriptor() ([]byte, []int) { return fileDescriptorCvss, []int{3} }

func (m *Vector) GetBaseMetrics() *BaseMetrics {
	if m != nil {
		return m.BaseMetrics
	}
	return nil
}

func (m *Vector) GetTemporalMetrics() *TemporalMetrics {
	if m != nil {
		return m.TemporalMetrics
	}
	return nil
}

func (m *Vector) GetEnvironmentalMetrics() *EnvironmentalMetrics {
	if m != nil {
		return m.EnvironmentalMetrics
	}
	return nil
}

// Score defines all CVSS intermediate and final calculus.
type Score struct {
	BaseScore          *BaseScore          `protobuf:"bytes,1,opt,name=base_score,json=baseScore" json:"base_score,omitempty"`
	TemporalScore      *TemporalScore      `protobuf:"bytes,2,opt,name=temporal_score,json=temporalScore" json:"temporal_score,omitempty"`
	EnvironmentalScore *EnvironmentalScore `protobuf:"bytes,3,opt,name=environmental_score,json=environmentalScore" json:"environmental_score,omitempty"`
}

func (m *Score) Reset()                    { *m = Score{} }
func (m *Score) String() string            { return proto.CompactTextString(m) }
func (*Score) ProtoMessage()               {}
func (*Score) Descriptor() ([]byte, []int) { return fileDescriptorCvss, []int{4} }

func (m *Score) GetBaseScore() *BaseScore {
	if m != nil {
		return m.BaseScore
	}
	return nil
}

func (m *Score) GetTemporalScore() *TemporalScore {
	if m != nil {
		return m.TemporalScore
	}
	return nil
}

func (m *Score) GetEnvironmentalScore() *EnvironmentalScore {
	if m != nil {
		return m.EnvironmentalScore
	}
	return nil
}

// BaseScore regroups all calculus attributes for Base Metrics.
type BaseScore struct {
	AccessVector          float64 `protobuf:"fixed64,1,opt,name=access_vector,json=accessVector,proto3" json:"access_vector,omitempty"`
	AccessComplexity      float64 `protobuf:"fixed64,2,opt,name=access_complexity,json=accessComplexity,proto3" json:"access_complexity,omitempty"`
	Authentication        float64 `protobuf:"fixed64,3,opt,name=authentication,proto3" json:"authentication,omitempty"`
	ConfidentialityImpact float64 `protobuf:"fixed64,4,opt,name=confidentiality_impact,json=confidentialityImpact,proto3" json:"confidentiality_impact,omitempty"`
	IntegrityImpact       float64 `protobuf:"fixed64,5,opt,name=integrity_impact,json=integrityImpact,proto3" json:"integrity_impact,omitempty"`
	AvailabilityImpact    float64 `protobuf:"fixed64,6,opt,name=availability_impact,json=availabilityImpact,proto3" json:"availability_impact,omitempty"`
	Impact                float64 `protobuf:"fixed64,7,opt,name=impact,proto3" json:"impact,omitempty"`
	FImpact               float64 `protobuf:"fixed64,8,opt,name=f_impact,json=fImpact,proto3" json:"f_impact,omitempty"`
	Exploitability        float64 `protobuf:"fixed64,9,opt,name=exploitability,proto3" json:"exploitability,omitempty"`
	Score                 float64 `protobuf:"fixed64,10,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *BaseScore) Reset()                    { *m = BaseScore{} }
func (m *BaseScore) String() string            { return proto.CompactTextString(m) }
func (*BaseScore) ProtoMessage()               {}
func (*BaseScore) Descriptor() ([]byte, []int) { return fileDescriptorCvss, []int{5} }

func (m *BaseScore) GetAccessVector() float64 {
	if m != nil {
		return m.AccessVector
	}
	return 0
}

func (m *BaseScore) GetAccessComplexity() float64 {
	if m != nil {
		return m.AccessComplexity
	}
	return 0
}

func (m *BaseScore) GetAuthentication() float64 {
	if m != nil {
		return m.Authentication
	}
	return 0
}

func (m *BaseScore) GetConfidentialityImpact() float64 {
	if m != nil {
		return m.ConfidentialityImpact
	}
	return 0
}

func (m *BaseScore) GetIntegrityImpact() float64 {
	if m != nil {
		return m.IntegrityImpact
	}
	return 0
}

func (m *BaseScore) GetAvailabilityImpact() float64 {
	if m != nil {
		return m.AvailabilityImpact
	}
	return 0
}

func (m *BaseScore) GetImpact() float64 {
	if m != nil {
		return m.Impact
	}
	return 0
}

func (m *BaseScore) GetFImpact() float64 {
	if m != nil {
		return m.FImpact
	}
	return 0
}

func (m *BaseScore) GetExploitability() float64 {
	if m != nil {
		return m.Exploitability
	}
	return 0
}

func (m *BaseScore) GetScore() float64 {
	if m != nil {
		return m.Score
	}
	return 0
}

// TemporalScore regroups all calculus attributes for Temporal Metrics.
type TemporalScore struct {
	Exploitability   float64 `protobuf:"fixed64,1,opt,name=exploitability,proto3" json:"exploitability,omitempty"`
	RemediationLevel float64 `protobuf:"fixed64,2,opt,name=remediation_level,json=remediationLevel,proto3" json:"remediation_level,omitempty"`
	ReportConfidence float64 `protobuf:"fixed64,3,opt,name=report_confidence,json=reportConfidence,proto3" json:"report_confidence,omitempty"`
	Score            float64 `protobuf:"fixed64,4,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *TemporalScore) Reset()                    { *m = TemporalScore{} }
func (m *TemporalScore) String() string            { return proto.CompactTextString(m) }
func (*TemporalScore) ProtoMessage()               {}
func (*TemporalScore) Descriptor() ([]byte, []int) { return fileDescriptorCvss, []int{6} }

func (m *TemporalScore) GetExploitability() float64 {
	if m != nil {
		return m.Exploitability
	}
	return 0
}

func (m *TemporalScore) GetRemediationLevel() float64 {
	if m != nil {
		return m.RemediationLevel
	}
	return 0
}

func (m *TemporalScore) GetReportConfidence() float64 {
	if m != nil {
		return m.ReportConfidence
	}
	return 0
}

func (m *TemporalScore) GetScore() float64 {
	if m != nil {
		return m.Score
	}
	return 0
}

// EnvironmentalScore regroups all calculus attributes for Environmental Metrics.
type EnvironmentalScore struct {
	CollateralDamagePotential  float64 `protobuf:"fixed64,1,opt,name=collateral_damage_potential,json=collateralDamagePotential,proto3" json:"collateral_damage_potential,omitempty"`
	TargetDistribution         float64 `protobuf:"fixed64,2,opt,name=target_distribution,json=targetDistribution,proto3" json:"target_distribution,omitempty"`
	ConfidentialityRequirement float64 `protobuf:"fixed64,3,opt,name=confidentiality_requirement,json=confidentialityRequirement,proto3" json:"confidentiality_requirement,omitempty"`
	IntegrityRequirement       float64 `protobuf:"fixed64,4,opt,name=integrity_requirement,json=integrityRequirement,proto3" json:"integrity_requirement,omitempty"`
	AvailabilityRequirement    float64 `protobuf:"fixed64,5,opt,name=availability_requirement,json=availabilityRequirement,proto3" json:"availability_requirement,omitempty"`
	AdjustedImpact             float64 `protobuf:"fixed64,6,opt,name=adjusted_impact,json=adjustedImpact,proto3" json:"adjusted_impact,omitempty"`
	AdjustedBase               float64 `protobuf:"fixed64,7,opt,name=adjusted_base,json=adjustedBase,proto3" json:"adjusted_base,omitempty"`
	AdjustedTemporal           float64 `protobuf:"fixed64,8,opt,name=adjusted_temporal,json=adjustedTemporal,proto3" json:"adjusted_temporal,omitempty"`
	Score                      float64 `protobuf:"fixed64,9,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *EnvironmentalScore) Reset()                    { *m = EnvironmentalScore{} }
func (m *EnvironmentalScore) String() string            { return proto.CompactTextString(m) }
func (*EnvironmentalScore) ProtoMessage()               {}
func (*EnvironmentalScore) Descriptor() ([]byte, []int) { return fileDescriptorCvss, []int{7} }

func (m *EnvironmentalScore) GetCollateralDamagePotential() float64 {
	if m != nil {
		return m.CollateralDamagePotential
	}
	return 0
}

func (m *EnvironmentalScore) GetTargetDistribution() float64 {
	if m != nil {
		return m.TargetDistribution
	}
	return 0
}

func (m *EnvironmentalScore) GetConfidentialityRequirement() float64 {
	if m != nil {
		return m.ConfidentialityRequirement
	}
	return 0
}

func (m *EnvironmentalScore) GetIntegrityRequirement() float64 {
	if m != nil {
		return m.IntegrityRequirement
	}
	return 0
}

func (m *EnvironmentalScore) GetAvailabilityRequirement() float64 {
	if m != nil {
		return m.AvailabilityRequirement
	}
	return 0
}

func (m *EnvironmentalScore) GetAdjustedImpact() float64 {
	if m != nil {
		return m.AdjustedImpact
	}
	return 0
}

func (m *EnvironmentalScore) GetAdjustedBase() float64 {
	if m != nil {
		return m.AdjustedBase
	}
	return 0
}

func (m *EnvironmentalScore) GetAdjustedTemporal() float64 {
	if m != nil {
		return m.AdjustedTemporal
	}
	return 0
}

func (m *EnvironmentalScore) GetScore() float64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func init() {
	proto.RegisterType((*BaseMetrics)(nil), "mitre.cvss.v2.BaseMetrics")
	proto.RegisterType((*TemporalMetrics)(nil), "mitre.cvss.v2.TemporalMetrics")
	proto.RegisterType((*EnvironmentalMetrics)(nil), "mitre.cvss.v2.EnvironmentalMetrics")
	proto.RegisterType((*Vector)(nil), "mitre.cvss.v2.Vector")
	proto.RegisterType((*Score)(nil), "mitre.cvss.v2.Score")
	proto.RegisterType((*BaseScore)(nil), "mitre.cvss.v2.BaseScore")
	proto.RegisterType((*TemporalScore)(nil), "mitre.cvss.v2.TemporalScore")
	proto.RegisterType((*EnvironmentalScore)(nil), "mitre.cvss.v2.EnvironmentalScore")
	proto.RegisterEnum("mitre.cvss.v2.AccessVector", AccessVector_name, AccessVector_value)
	proto.RegisterEnum("mitre.cvss.v2.AccessComplexity", AccessComplexity_name, AccessComplexity_value)
	proto.RegisterEnum("mitre.cvss.v2.Authentication", Authentication_name, Authentication_value)
	proto.RegisterEnum("mitre.cvss.v2.ConfidentialityImpact", ConfidentialityImpact_name, ConfidentialityImpact_value)
	proto.RegisterEnum("mitre.cvss.v2.IntegrityImpact", IntegrityImpact_name, IntegrityImpact_value)
	proto.RegisterEnum("mitre.cvss.v2.AvailabilityImpact", AvailabilityImpact_name, AvailabilityImpact_value)
	proto.RegisterEnum("mitre.cvss.v2.Exploitability", Exploitability_name, Exploitability_value)
	proto.RegisterEnum("mitre.cvss.v2.RemediationLevel", RemediationLevel_name, RemediationLevel_value)
	proto.RegisterEnum("mitre.cvss.v2.ReportConfidence", ReportConfidence_name, ReportConfidence_value)
	proto.RegisterEnum("mitre.cvss.v2.CollateralDamagePotential", CollateralDamagePotential_name, CollateralDamagePotential_value)
	proto.RegisterEnum("mitre.cvss.v2.TargetDistribution", TargetDistribution_name, TargetDistribution_value)
	proto.RegisterEnum("mitre.cvss.v2.SecurityRequirement", SecurityRequirement_name, SecurityRequirement_value)
	proto.RegisterEnum("mitre.cvss.v2.Severity", Severity_name, Severity_value)
}

func init() { proto.RegisterFile("pkg/protocol/mitre/cvss/v2/cvss.proto", fileDescriptorCvss) }

var fileDescriptorCvss = []byte{
	// 1698 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x58, 0x4d, 0x6f, 0xdb, 0xc8,
	0x19, 0xee, 0x48, 0xb2, 0x37, 0x7e, 0xe3, 0x0f, 0xee, 0x38, 0x8e, 0xbf, 0x12, 0x3b, 0x91, 0xd3,
	0x64, 0xeb, 0x00, 0x36, 0xe0, 0x45, 0x51, 0xf4, 0xd0, 0x0f, 0x9a, 0x1a, 0x39, 0x6c, 0x29, 0x52,
	0x1d, 0x51, 0x8a, 0xb7, 0xdd, 0x82, 0xa0, 0x69, 0xc6, 0x61, 0x2b, 0x89, 0x2a, 0x45, 0x0b, 0xbb,
	0xfd, 0x07, 0xfd, 0x0d, 0x05, 0x7a, 0xe8, 0x65, 0x81, 0xfe, 0x83, 0x62, 0x81, 0x1e, 0x5b, 0xa0,
	0x3d, 0xf6, 0xd4, 0x5b, 0x7b, 0xef, 0xa5, 0x40, 0x7f, 0xc0, 0x62, 0x86, 0xa4, 0x34, 0x24, 0x87,
	0x76, 0x4e, 0x36, 0xdf, 0xf7, 0x99, 0x67, 0xde, 0xaf, 0x79, 0x86, 0x14, 0x7c, 0x7b, 0xf2, 0xeb,
	0x9b, 0xd3, 0x49, 0x14, 0xc6, 0xa1, 0x17, 0x0e, 0x4f, 0x47, 0x41, 0x1c, 0xf9, 0xa7, 0xde, 0x6c,
	0x3a, 0x3d, 0x9d, 0x9d, 0xf1, 0xbf, 0x27, 0xdc, 0x87, 0xd7, 0xb8, 0xe7, 0x84, 0x5b, 0x66, 0x67,
	0xcd, 0x7f, 0xd7, 0xe1, 0xe1, 0xb9, 0x3b, 0xf5, 0x3b, 0x7e, 0x1c, 0x05, 0xde, 0x14, 0xff, 0x18,
	0xd6, 0x5c, 0xcf, 0xf3, 0xa7, 0x53, 0x67, 0xe6, 0x7b, 0x71, 0x18, 0xed, 0xa0, 0x67, 0xe8, 0x93,
	0xf5, 0xb3, 0xfd, 0x93, 0xdc, 0xb2, 0x13, 0x95, 0x63, 0x06, 0x1c, 0x42, 0x57, 0x5d, 0xe1, 0x09,
	0x1b, 0xf0, 0x71, 0xca, 0xe0, 0x85, 0xa3, 0xc9, 0xd0, 0xff, 0x22, 0x88, 0xbf, 0xdc, 0xa9, 0x71,
	0x96, 0x43, 0x29, 0x8b, 0x36, 0x87, 0x51, 0xc5, 0x2d, 0x58, 0x30, 0x81, 0x75, 0xf7, 0x36, 0x7e,
	0xef, 0x8f, 0xe3, 0xc0, 0x73, 0xe3, 0x20, 0x1c, 0xef, 0xd4, 0x39, 0xd5, 0xd3, 0x22, 0x55, 0x0e,
	0x44, 0x0b, 0x8b, 0xf0, 0x2f, 0xe0, 0xb1, 0x17, 0x8e, 0xdf, 0x05, 0xd7, 0xcc, 0xe6, 0x0e, 0x83,
	0xf8, 0x4b, 0x27, 0x18, 0x4d, 0x5c, 0x2f, 0xde, 0x69, 0x70, 0xba, 0x17, 0x05, 0x3a, 0x2d, 0x0f,
	0xd6, 0x39, 0x96, 0x6e, 0x79, 0x32, 0x33, 0xd6, 0x41, 0x09, 0xc6, 0xb1, 0x7f, 0x13, 0x09, 0xb4,
	0x4b, 0x9c, 0xf6, 0xa0, 0x40, 0xab, 0x67, 0xb0, 0x94, 0x70, 0x23, 0xc8, 0x1b, 0x30, 0x85, 0x4d,
	0x77, 0xe6, 0x06, 0x43, 0xf7, 0x2a, 0x10, 0x83, 0x5c, 0xe6, 0x6c, 0xcf, 0x8b, 0x39, 0x0b, 0xc8,
	0x94, 0x10, 0xbb, 0x25, 0x5b, 0xf3, 0xff, 0x08, 0x36, 0x6c, 0x7f, 0x34, 0x09, 0x23, 0x77, 0x98,
	0xb5, 0x99, 0xc0, 0xba, 0xff, 0xc5, 0x64, 0x18, 0x06, 0x71, 0x8a, 0x4d, 0xfb, 0x5c, 0x2c, 0x2b,
	0xc9, 0x81, 0x68, 0x61, 0x11, 0xeb, 0x75, 0xe4, 0x8f, 0xfc, 0xeb, 0x80, 0x57, 0xd9, 0x19, 0xfa,
	0x33, 0x7f, 0x58, 0xd1, 0x6b, 0xba, 0xc0, 0x19, 0x0c, 0x46, 0x95, 0xa8, 0x60, 0x49, 0xd8, 0x26,
	0x61, 0x14, 0x3b, 0x59, 0x9d, 0x3d, 0x3f, 0x6d, 0x77, 0x99, 0x8d, 0xe1, 0xb4, 0x39, 0x8c, 0xb1,
	0xe5, 0x2d, 0xcd, 0xff, 0xd5, 0xe1, 0x11, 0x19, 0xcf, 0x82, 0x28, 0x1c, 0x8f, 0xfc, 0x71, 0xbc,
	0xc8, 0xfd, 0x3d, 0xec, 0x7b, 0xe1, 0x70, 0xe8, 0xc6, 0x7e, 0xe4, 0x0e, 0x9d, 0x6b, 0x77, 0xe4,
	0xde, 0xf8, 0xce, 0x24, 0x8c, 0x93, 0xb6, 0xa6, 0x85, 0xf8, 0xa4, 0x34, 0x10, 0xd9, 0x8a, 0x16,
	0x5f, 0xd0, 0xcd, 0xf0, 0x74, 0xd7, 0xab, 0x72, 0xb1, 0x6e, 0xc6, 0x6e, 0x74, 0xe3, 0xc7, 0xce,
	0x75, 0x30, 0x8d, 0xa3, 0xe0, 0xea, 0x96, 0x4f, 0x70, 0x4d, 0xda, 0x4d, 0x9b, 0x23, 0x5b, 0x02,
	0x90, 0xe2, 0xb8, 0x64, 0xc3, 0x1e, 0x8b, 0x3e, 0x3f, 0xc9, 0x91, 0xff, 0x9b, 0xdb, 0x80, 0x55,
	0x73, 0x1c, 0xa7, 0xe5, 0x6a, 0x16, 0xb8, 0x7b, 0xbe, 0x77, 0xcb, 0xa6, 0x8c, 0x2e, 0x90, 0x74,
	0xaf, 0x40, 0x23, 0xf8, 0xf0, 0x5b, 0xd8, 0x5a, 0x4c, 0xb4, 0x48, 0xdf, 0xf8, 0x60, 0xfa, 0x47,
	0x73, 0x02, 0x91, 0xf8, 0x97, 0xb0, 0x93, 0x9b, 0x6f, 0x91, 0x7b, 0xe9, 0x83, 0xb9, 0xb7, 0x45,
	0x0e, 0xc1, 0xd1, 0xfc, 0x2f, 0x82, 0xe5, 0x54, 0x86, 0x7e, 0x00, 0xab, 0x57, 0xee, 0xd4, 0x77,
	0x46, 0x49, 0xd7, 0x79, 0x5b, 0x1f, 0x9e, 0xed, 0x15, 0xd8, 0x05, 0xe9, 0xa3, 0x0f, 0xaf, 0x04,
	0x1d, 0xd4, 0x41, 0x89, 0xd3, 0x33, 0x33, 0xa7, 0xa8, 0x71, 0x8a, 0xe2, 0x99, 0x2e, 0x1c, 0x2d,
	0xba, 0x11, 0x17, 0xce, 0xda, 0x25, 0x6c, 0xf9, 0xe2, 0x1c, 0xce, 0xf9, 0xea, 0x9c, 0xef, 0xa8,
	0x78, 0xe4, 0x24, 0x33, 0x4b, 0x1f, 0xf9, 0x12, 0x6b, 0xf3, 0x5f, 0x08, 0x96, 0x7a, 0x5e, 0x18,
	0xf9, 0xf8, 0x7b, 0x00, 0x3c, 0xdb, 0x29, 0x7b, 0x4a, 0x73, 0xdd, 0x91, 0xe4, 0xca, 0xd1, 0x74,
	0xe5, 0x2a, 0xfb, 0x17, 0x6b, 0xb0, 0x3e, 0xcf, 0x33, 0x59, 0x9c, 0x64, 0xf9, 0xa4, 0x22, 0xcb,
	0x84, 0x60, 0x2d, 0x16, 0x1f, 0xd9, 0x9c, 0xe7, 0x33, 0x4c, 0x98, 0x92, 0xfc, 0x9e, 0xdf, 0x95,
	0x5f, 0x42, 0x87, 0xfd, 0x92, 0xad, 0xf9, 0xbb, 0x3a, 0xac, 0xcc, 0x23, 0xc6, 0x47, 0xb2, 0x6b,
	0x09, 0x15, 0x6e, 0x9e, 0xd7, 0x55, 0x37, 0x0f, 0x92, 0x5c, 0x2c, 0x2f, 0xa5, 0x17, 0x0b, 0x2a,
	0xdd, 0x1c, 0xdf, 0xbd, 0xf3, 0xe6, 0x40, 0x55, 0x77, 0xc2, 0x77, 0x2a, 0xee, 0x04, 0x54, 0xd6,
	0xfc, 0xd3, 0x6a, 0xcd, 0x47, 0x32, 0x41, 0xc7, 0x8f, 0x61, 0x39, 0xc5, 0x7c, 0xc4, 0x31, 0xe9,
	0x13, 0xde, 0x85, 0x07, 0xef, 0xb2, 0xd5, 0x0f, 0xb8, 0xe7, 0xa3, 0x77, 0xe9, 0x92, 0x97, 0x25,
	0xbd, 0x5f, 0x49, 0xb2, 0x2d, 0x08, 0xfa, 0x23, 0x58, 0x4a, 0x7a, 0x07, 0xdc, 0x9d, 0x3c, 0x34,
	0xbf, 0x42, 0xb0, 0x96, 0x1b, 0x00, 0x09, 0x1f, 0x92, 0xf2, 0xbd, 0xae, 0xba, 0x20, 0x90, 0x44,
	0xff, 0x5f, 0x57, 0xe9, 0x3f, 0x2a, 0xcb, 0xfb, 0x22, 0xd2, 0x86, 0x18, 0xe9, 0xdf, 0xea, 0x80,
	0xcb, 0x03, 0x86, 0x7f, 0x78, 0xbf, 0xe4, 0xa3, 0xbb, 0x84, 0xfc, 0xb4, 0x5a, 0xc8, 0x91, 0x54,
	0xa5, 0x7f, 0x74, 0xbf, 0x4a, 0xa3, 0x3b, 0x15, 0xf8, 0xd3, 0xbb, 0x14, 0x18, 0x55, 0xa8, 0xeb,
	0xf7, 0xef, 0x51, 0x57, 0x54, 0xa9, 0x9c, 0xf8, 0x15, 0x6c, 0xb8, 0xd7, 0xbf, 0xba, 0x9d, 0xc6,
	0xfe, 0x75, 0x7e, 0x00, 0xd7, 0x33, 0x73, 0x3a, 0x49, 0xec, 0x24, 0x66, 0x40, 0x26, 0x23, 0xe9,
	0x0c, 0xae, 0x66, 0x46, 0x76, 0x66, 0xf9, 0x49, 0xcc, 0x40, 0x99, 0x54, 0xa4, 0x23, 0xa9, 0x64,
	0x8e, 0x6c, 0xa0, 0x16, 0x9d, 0x5c, 0x11, 0x3a, 0x79, 0xfc, 0x07, 0x04, 0xab, 0xe2, 0x5b, 0x26,
	0xde, 0x85, 0x2d, 0x55, 0xd3, 0x48, 0xaf, 0xe7, 0x0c, 0x88, 0x66, 0x5b, 0xd4, 0xd1, 0xcd, 0x81,
	0x6a, 0xe8, 0x2d, 0xe5, 0x5b, 0x78, 0x1f, 0xb6, 0xf3, 0xae, 0xbe, 0xd9, 0x22, 0x6d, 0xdd, 0x24,
	0x2d, 0x05, 0xe1, 0x6d, 0xd8, 0xcc, 0x3b, 0x0d, 0x4b, 0x53, 0x0d, 0xa5, 0x86, 0x9b, 0x70, 0x90,
	0x77, 0xa8, 0xad, 0x9f, 0xa8, 0x1a, 0x31, 0x6d, 0xc7, 0x24, 0xf6, 0x5b, 0x8b, 0xfe, 0x54, 0xa9,
	0x97, 0x37, 0xcd, 0x5c, 0x8d, 0xe3, 0xaf, 0x10, 0x28, 0xc5, 0x17, 0x58, 0xfc, 0x14, 0x76, 0x53,
	0xbc, 0x66, 0x75, 0xba, 0x06, 0xb9, 0xd4, 0xed, 0xcf, 0x84, 0x40, 0x0f, 0x61, 0xbf, 0xec, 0x16,
	0x83, 0xdd, 0x83, 0xc7, 0x65, 0xc0, 0x1b, 0xfd, 0xe2, 0x8d, 0x52, 0xc3, 0x4f, 0x60, 0xa7, 0xec,
	0xeb, 0x90, 0x96, 0xde, 0xef, 0xe4, 0x22, 0x15, 0xbc, 0x86, 0xf5, 0x56, 0x69, 0x1c, 0xff, 0x1e,
	0xc1, 0x7a, 0xfe, 0xfd, 0x98, 0xef, 0xd3, 0xb7, 0xdf, 0x10, 0xd3, 0xd6, 0x35, 0xd5, 0xd6, 0x2d,
	0x53, 0x08, 0x92, 0xed, 0x93, 0xf7, 0x89, 0x11, 0xb2, 0x5a, 0xe7, 0xbd, 0x9d, 0xbe, 0x61, 0xeb,
	0x5d, 0x83, 0x28, 0x35, 0x1e, 0x44, 0xde, 0xd9, 0xd3, 0xcd, 0x0b, 0x83, 0x28, 0x75, 0xde, 0x86,
	0xbc, 0xcb, 0xb4, 0x4c, 0xa2, 0x34, 0x8e, 0xff, 0x81, 0x60, 0x4b, 0xfa, 0xba, 0xcd, 0x1a, 0xa4,
	0x59, 0x66, 0x5b, 0x6f, 0xb1, 0x45, 0xaa, 0xc1, 0x4b, 0xd9, 0xe9, 0xaa, 0x9a, 0x2d, 0x04, 0xfb,
	0x02, 0x9e, 0x55, 0x60, 0xc4, 0xa0, 0x0f, 0x61, 0xbf, 0x02, 0xc5, 0x83, 0xa8, 0xdd, 0xb1, 0x55,
	0x57, 0xa5, 0xcc, 0xa2, 0xd4, 0xf1, 0x11, 0x1c, 0x56, 0x60, 0x92, 0x8a, 0xdb, 0x24, 0x99, 0x8a,
	0x8d, 0xc2, 0x5b, 0x3e, 0x2b, 0xa8, 0x6e, 0xda, 0xe4, 0x82, 0x4a, 0x33, 0x38, 0x80, 0xbd, 0x92,
	0x57, 0x8c, 0x7d, 0x17, 0xb6, 0x4a, 0xfe, 0x34, 0x6a, 0x19, 0xf1, 0x22, 0xde, 0xa7, 0xb0, 0x5b,
	0xf2, 0x0a, 0x91, 0xfe, 0x19, 0x01, 0x2e, 0x7f, 0x41, 0xf0, 0x11, 0x1d, 0xa8, 0xba, 0xa1, 0x9e,
	0xeb, 0xf2, 0x8a, 0x3f, 0x87, 0xa7, 0x32, 0x80, 0x18, 0x32, 0x9b, 0x20, 0x09, 0x24, 0x8d, 0xba,
	0x62, 0x87, 0x45, 0xe0, 0xcf, 0xe0, 0x89, 0x0c, 0x20, 0xc4, 0xfe, 0x57, 0x04, 0xeb, 0xf9, 0x4f,
	0x13, 0x36, 0xd1, 0xe4, 0xb2, 0x6b, 0x58, 0xba, 0x3d, 0x5f, 0x26, 0xea, 0x43, 0xc1, 0xd7, 0x37,
	0xbb, 0xd4, 0x1a, 0x10, 0x53, 0x41, 0xac, 0xad, 0x05, 0x67, 0x97, 0x5a, 0x56, 0xdb, 0xb1, 0xda,
	0x8e, 0x66, 0x99, 0x1a, 0xe9, 0xda, 0x4a, 0x8d, 0xd5, 0xb2, 0x00, 0x6a, 0xf7, 0x4d, 0x8d, 0x8d,
	0x31, 0x8f, 0x78, 0x1b, 0x36, 0x0b, 0x6e, 0x7e, 0x66, 0x1b, 0xac, 0xb9, 0x05, 0x87, 0x69, 0xd9,
	0x4e, 0x56, 0xa9, 0xa5, 0xe3, 0xff, 0x20, 0x50, 0x8a, 0x5f, 0x46, 0x6c, 0x33, 0x4a, 0xd8, 0xc1,
	0x4e, 0xce, 0x89, 0x41, 0x06, 0xc4, 0x10, 0xb2, 0x69, 0xc2, 0x41, 0xd9, 0x6d, 0xb5, 0xdb, 0xba,
	0xa6, 0xab, 0x86, 0xd3, 0xd6, 0x2f, 0x93, 0xa4, 0xca, 0x18, 0x9b, 0x74, 0xba, 0x16, 0x55, 0xe9,
	0x67, 0x1c, 0x54, 0x63, 0x75, 0x2e, 0x83, 0x98, 0xba, 0xa9, 0xd4, 0xea, 0x9b, 0x2d, 0xa5, 0xce,
	0x7a, 0x5d, 0x46, 0xf4, 0xcd, 0xb4, 0x3b, 0x06, 0x51, 0x1a, 0x72, 0x12, 0xd3, 0x12, 0x72, 0xfc,
	0x0b, 0xcf, 0xb1, 0x70, 0x7d, 0xf3, 0x1c, 0xbb, 0x16, 0x65, 0x6d, 0x4d, 0xce, 0x94, 0x46, 0xf2,
	0x43, 0x56, 0x76, 0xf7, 0x4d, 0xfe, 0x40, 0x3b, 0x7c, 0xc8, 0x5e, 0xc0, 0x33, 0x39, 0x84, 0x52,
	0xeb, 0xdc, 0xa2, 0xaa, 0x4d, 0x5a, 0xc9, 0xb0, 0x95, 0x51, 0x0b, 0x9a, 0xba, 0x7c, 0x27, 0xb1,
	0x49, 0x8d, 0xe3, 0xaf, 0x6b, 0xb0, 0x5b, 0xf9, 0xfd, 0x87, 0x5f, 0xc1, 0x91, 0x66, 0x19, 0x86,
	0x6a, 0x13, 0xaa, 0x1a, 0x4e, 0x4b, 0xed, 0xa8, 0x17, 0xc4, 0xe9, 0x5a, 0x76, 0xa2, 0x12, 0x45,
	0xa9, 0xaa, 0x06, 0xf2, 0xd3, 0x81, 0x12, 0x95, 0xa9, 0x46, 0x31, 0x45, 0xaf, 0xe1, 0x63, 0x78,
	0x79, 0x0f, 0x68, 0x71, 0x31, 0xbc, 0x86, 0x57, 0x77, 0x61, 0x13, 0x5c, 0x36, 0xaf, 0xf7, 0xc4,
	0xc8, 0x51, 0x4b, 0xf7, 0x51, 0x8a, 0xd5, 0x5b, 0x3e, 0xfe, 0x27, 0x02, 0x5c, 0xfe, 0xb6, 0x65,
	0x8d, 0xb1, 0x55, 0x7a, 0x41, 0x6c, 0xa7, 0xa5, 0xf7, 0x6c, 0xaa, 0x9f, 0xf7, 0xcb, 0xd7, 0x90,
	0x0c, 0x90, 0x96, 0x69, 0x1f, 0xb6, 0x65, 0xde, 0xa4, 0x3c, 0x07, 0xb0, 0x27, 0x73, 0xce, 0x4b,
	0x52, 0x41, 0x9d, 0xd6, 0xe0, 0x08, 0x0e, 0xe5, 0x1b, 0x8b, 0x07, 0xf7, 0x6b, 0x04, 0x9b, 0x92,
	0x4f, 0x53, 0x76, 0x1c, 0x7a, 0x44, 0xeb, 0x73, 0xcd, 0xa5, 0xe4, 0x67, 0x7d, 0x9d, 0x1d, 0x0e,
	0xd3, 0xce, 0xe7, 0x25, 0x45, 0xb0, 0xd0, 0xf9, 0x4d, 0x25, 0xf5, 0xa6, 0xb1, 0x73, 0x25, 0x92,
	0x02, 0x78, 0xf0, 0x75, 0xd6, 0x40, 0xa9, 0x3b, 0x3f, 0xd1, 0x11, 0x3c, 0xe8, 0xf9, 0x33, 0x3f,
	0x4a, 0x5e, 0xf9, 0x95, 0x1e, 0x19, 0x10, 0x9a, 0x97, 0xcc, 0xc7, 0x80, 0xe7, 0x56, 0x51, 0xda,
	0x15, 0x58, 0x9d, 0xdb, 0x93, 0x62, 0x6f, 0xc2, 0xc6, 0xdc, 0x32, 0xaf, 0xf0, 0xc7, 0xb0, 0x36,
	0x37, 0x26, 0x65, 0x3d, 0x7f, 0x0b, 0x7b, 0x61, 0x74, 0x73, 0xf2, 0x5b, 0x7f, 0x1c, 0xc4, 0xef,
	0xdd, 0x28, 0xff, 0x55, 0x78, 0xbe, 0xa2, 0xcd, 0xa6, 0xd3, 0x6e, 0x14, 0xc6, 0x61, 0x17, 0xfd,
	0x7c, 0x99, 0x59, 0x67, 0x67, 0x7f, 0xac, 0xd5, 0x3b, 0xda, 0xe5, 0x9f, 0x6a, 0x6b, 0x1d, 0x0e,
	0x65, 0x88, 0x93, 0xc1, 0xd9, 0xdf, 0xd3, 0xe7, 0xcf, 0xd9, 0xf3, 0xe7, 0x83, 0xb3, 0xab, 0x65,
	0xfe, 0xc3, 0xe6, 0xa7, 0xdf, 0x04, 0x00, 0x00, 0xff, 0xff, 0xc6, 0x04, 0xa4, 0x96, 0x01, 0x15,
	0x00, 0x00,
}
